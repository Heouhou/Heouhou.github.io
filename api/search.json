[{"id":"078f7e9be7e83a4bdc132dd63c7d9a7c","title":"List和Array 中遇到的问题。","content":"List和Array 中遇到的问题。前言\n\n\n\n\n\n\n\n\n主要介绍Array 和List 互相转换时遇到的问题，以及怎么解决\nArrays.asList转换的坑问题1:基本类型数组转换List会出现转换出的结果跟想要的不一致\n\n\n\n\n\n\n\n\n我们进行数组转List的操作时，通常我们会使用Arrays.asList来进行转换。\n但是在转换基本类型的数组的时候，却出现转换的结果和我们想象的不一致。\n例如：\nvoid Test1()&#123;\n  int[] arr &#x3D; &#123;1, 2, 3&#125;;\n  List list &#x3D; Arrays.asList(arr);\n  System.out.println(list.size());\n  &#x2F;&#x2F;1\n&#125;\n\n我们的目的是想生成一个长度为3的List,可是现在只生成了长度为1 的List\n@SafeVarargs\n@SuppressWarnings(&quot;varargs&quot;)\npublic static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123;\n  return new ArrayList&lt;&gt;(a);\n&#125;\n\n问题原因:通过断点我们可以看到把 int数组 整体作为一个对象,返回了一个 List&lt;int[]&gt;\n这个源码的截图看出来的问题就是的这里出入的参数类型是泛型T，这就是问题的根源。这个T表示派生自Object类的任何类，比如String,Integer,Double等等。泛型只能是引用类型,基础类型int、double等不是引用类型，但是数组是引用类型，那么这个参数泛型T只能是数组的引用类型。所以我们传基础类数组的时候，就只会认为你只传一个值。\n解决方案方案一：Java8以上，利用Arrays.stream(arr).boxed()将装箱为Integer数组\nList collect &#x3D; Arrays.stream(arr).boxed().collect(Collectors.toList()); \nSystem.out.println(collect.size()); \nSystem.out.println(collect.get(0).getClass()); \n&#x2F;&#x2F; 3 \n&#x2F;&#x2F; class java.lang.Integer\n\n方案二：声明数组的时候，声明类型改为包装类型\nInteger[] integerArr &#x3D; &#123;1, 2, 3&#125;; \nList integerList &#x3D; Arrays.asList(integerArr); \nSystem.out.println(integerList.size());\nSystem.out.println(integerList.get(0).getClass()); \n&#x2F;&#x2F; 3 \n&#x2F;&#x2F; class java.lang.Integer\n\n问题2： Arrays.asList返回的List不支持增删操作\n\n\n\n\n\n\n\n\n使用Arrays.asList 返回的List 进行增加、刪除操作时会报错。\n例如：\n1.迭代器删除\nString[] arr &#x3D; &#123;&quot;1&quot;, &quot;2&quot;, &quot;4&quot;&#125;;\nList&lt;String&gt; strings &#x3D; Arrays.asList(arr);\n&#x2F;&#x2F; arr[2] &#x3D; &quot;4&quot;;\nSystem.out.println(strings);\nIterator&lt;String&gt; iterator &#x3D; strings.iterator();\nwhile (iterator.hasNext()) &#123;\n  if (&quot;4&quot;.equals(iterator.next())) &#123;\n    iterator.remove();\n  &#125;\n&#125;\n\n&#x2F;&#x2F;[1, 2, 4]\n&#x2F;&#x2F;Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException: remove\n\t&#x2F;&#x2F;at java.base&#x2F;java.util.Iterator.remove(Iterator.java:102)\n\t&#x2F;&#x2F;at com.example.springbootdemo.test.ListTestDemo.main(ListTestDemo.java:21)\n\n2.调用remove 和add 方法\n\nString[] arr &#x3D; &#123;&quot;1&quot;, &quot;2&quot;, &quot;4&quot;&#125;;\nList&lt;String&gt; strings &#x3D; Arrays.asList(arr);\nstrings.remove(&quot;4&quot;);\n&#x2F;&#x2F;Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException: remove\n\t&#x2F;&#x2F;at java.base&#x2F;java.util.Iterator.remove(Iterator.java:102)\n\t&#x2F;&#x2F;at java.base&#x2F;java.util.AbstractCollection.remove(AbstractCollection.java:283)\n\t&#x2F;&#x2F;at com.example.springbootdemo.test.ListTestDemo.main(ListTestDemo.java:25)\n\nstrings.add(&quot;3&quot;);\n&#x2F;&#x2F;Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException\n\t&#x2F;&#x2F;at java.base&#x2F;java.util.AbstractList.add(AbstractList.java:153)\n\t&#x2F;&#x2F;at java.base&#x2F;java.util.AbstractList.add(AbstractList.java:111)\n\t&#x2F;&#x2F;at com.example.springbootdemo.test.ListTestDemo.main(ListTestDemo.java:26)\n\n\n问题原因:根据源码可知:Arrays.asList(arr); 方法返回的List是 自己内部定义的内部类ArrayList,继承AbstractList 类。但是并没有实现add和remove方法。所以直接调用的是AbstractList 类中的方法，直接抛出异常\n&#x2F;&#x2F;Arrays.class\n\n@SafeVarargs\n@SuppressWarnings(&quot;varargs&quot;)\npublic static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123;\n  return new ArrayList&lt;&gt;(a);\n&#125;\n\n&#x2F;**\n     * @serial include\n     *&#x2F;\nprivate static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;\n  implements RandomAccess, java.io.Serializable\n&#123;\n  @java.io.Serial\n  private static final long serialVersionUID &#x3D; -2764017481108945198L;\n  @SuppressWarnings(&quot;serial&quot;) &#x2F;&#x2F; Conditionally serializable\n  private final E[] a;\n\n  ArrayList(E[] array) &#123;\n    a &#x3D; Objects.requireNonNull(array);\n  &#125;\n\n  @Override\n  public int size() &#123;\n    return a.length;\n  &#125;\n\n  @Override\n  public Object[] toArray() &#123;\n    return Arrays.copyOf(a, a.length, Object[].class);\n  &#125;\n\n  @Override\n  @SuppressWarnings(&quot;unchecked&quot;)\n  public &lt;T&gt; T[] toArray(T[] a) &#123;\n    ...\n  &#125;\n\n  @Override\n  public E get(int index) &#123;\n    return a[index];\n  &#125;\n\n  @Override\n  public E set(int index, E element) &#123;\n    E oldValue &#x3D; a[index];\n    a[index] &#x3D; element;\n    return oldValue;\n  &#125;\n\n  @Override\n  public int indexOf(Object o) &#123;\n    ...\n  &#125;\n\n  @Override\n  public boolean contains(Object o) &#123;\n    return indexOf(o) &gt;&#x3D; 0;\n  &#125;\n\n  @Override\n  public Spliterator&lt;E&gt; spliterator() &#123;\n    return Spliterators.spliterator(a, Spliterator.ORDERED);\n  &#125;\n\n  @Override\n  public void forEach(Consumer&lt;? super E&gt; action) &#123;\n    ...\n  &#125;\n\n  @Override\n  public void replaceAll(UnaryOperator&lt;E&gt; operator) &#123;\n    ...\n  &#125;\n\n  @Override\n  public void sort(Comparator&lt;? super E&gt; c) &#123;\n    Arrays.sort(a, c);\n  &#125;\n\n  @Override\n  public Iterator&lt;E&gt; iterator() &#123;\n    return new ArrayItr&lt;&gt;(a);\n  &#125;\n&#125;\n\n&#x2F;&#x2F; AbstractList.class\npublic abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; &#123;\n  public void add(int index, E element) &#123;\n \t\tthrow new UnsupportedOperationException();\n  &#125;\n  public E remove(int index) &#123;\n  \tthrow new UnsupportedOperationException();\n  &#125;\n&#125;\n\n\n同理。Iterator 类也是自己的内部类，也没有实现Iterator中的remove方法\n&#x2F;&#x2F;Arrays.class\n\nprivate static class ArrayItr&lt;E&gt; implements Iterator&lt;E&gt; &#123;\n  private int cursor;\n  private final E[] a;\n\n  ArrayItr(E[] a) &#123;\n    this.a &#x3D; a;\n  &#125;\n\n  @Override\n  public boolean hasNext() &#123;\n    return cursor &lt; a.length;\n  &#125;\n\n  @Override\n  public E next() &#123;\n    int i &#x3D; cursor;\n    if (i &gt;&#x3D; a.length) &#123;\n      throw new NoSuchElementException();\n    &#125;\n    cursor &#x3D; i + 1;\n    return a[i];\n  &#125;\n&#125;\n\n&#x2F;&#x2F;Iterator.class\n\npublic interface Iterator&lt;E&gt; &#123;\n  default void remove() &#123;\n \t throw new UnsupportedOperationException(&quot;remove&quot;);\n  &#125;\n&#125;\n\n解决方案重新new 一个ArrayList来接收。\nString[] arr &#x3D; &#123;&quot;1&quot;, &quot;2&quot;, &quot;4&quot;&#125;;\nList&lt;String&gt; strings &#x3D; new ArrayList&lt;&gt;(Arrays.asList(arr));\n\nSystem.out.println(&quot;初始值:&quot; + strings);\nIterator&lt;String&gt; iterator &#x3D; strings.iterator();\nwhile (iterator.hasNext()) &#123;\n  if (&quot;4&quot;.equals(iterator.next())) &#123;\n    iterator.remove();\n  &#125;\n&#125;\nSystem.out.println(&quot;删除元素4:&quot; + strings);\nstrings.remove(&quot;2&quot;);\nSystem.out.println(&quot;删除元素2&quot; + strings);\nstrings.add(&quot;3&quot;);\nSystem.out.println(&quot;增加元素3&quot; + strings);\n\n初始值:[1, 2, 4]\n删除元素4:[1, 2]\n删除元素2[1]\n增加元素3[1, 3]\n\n问题3: 对原始数组的修改会影响到我们获得的那个List\n\n\n\n\n\n\n\n\n完成字符串数组转换为List之后，我们将字符串数组的第三个对象的值修改为4，发现List也发生了变化。\n例如:\nString[] arr &#x3D; &#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;&#125;;\nList&lt;String&gt; strings &#x3D; Arrays.asList(arr);\nSystem.out.println(&quot;原始值:&quot; + strings);\narr[2] &#x3D; &quot;4&quot;;\nSystem.out.println(&quot;修改后的值:&quot; + strings);\n\n&#x2F;&#x2F;原始值:[1, 2, 3]\n&#x2F;&#x2F;修改后的值:[1, 2, 4]\n\n问题原因:根据源码可知。asList中创建了 ArrayList，但是他直接引用了原本的数组对象。所以只要原本的数组对象一发生变化，List也跟着变化\n&#x2F;&#x2F;Arrays.class\n\n@SafeVarargs\n@SuppressWarnings(&quot;varargs&quot;)\npublic static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123;\n  return new ArrayList&lt;&gt;(a);\n&#125;\n\n&#x2F;**\n     * @serial include\n     *&#x2F;\nprivate static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;\n  implements RandomAccess, java.io.Serializable\n&#123;\n  @java.io.Serial\n    private static final long serialVersionUID &#x3D; -2764017481108945198L;\n  @SuppressWarnings(&quot;serial&quot;) &#x2F;&#x2F; Conditionally serializable\n  private final E[] a;\n\n  ArrayList(E[] array) &#123;\n    a &#x3D; Objects.requireNonNull(array);\n  &#125;\n  ...\n&#125;\npublic static &lt;T&gt; T requireNonNull(T obj) &#123;\n  if (obj &#x3D;&#x3D; null)\n    throw new NullPointerException();\n  return obj;\n&#125;\n\n所以在使用时一定要注意修改数组时会导致List的修改。\n解决方案重新new 一个ArrayList来接收。\nString[] arr &#x3D; &#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;&#125;;\nList&lt;String&gt; strings &#x3D; new ArrayList&lt;&gt;(Arrays.asList(arr));\nSystem.out.println(&quot;原始值:&quot; + strings);\narr[2] &#x3D; &quot;4&quot;;\nSystem.out.println(&quot;修改后的值:&quot; + strings);\n&#x2F;&#x2F;原始值:[1, 2, 3]\n&#x2F;&#x2F;修改后的值:[1, 2, 3]\n\n\nArrayList中 subList 方法的坑问题4：①ArrayList中的 subList 强转 ArrayList 导致异常。②并且对于SubList 的所有操作最终会反映到原列表上。\n\n\n\n\n\n\n\n\n在阿里巴巴的《JAVA开发手册》中，有关于subList 的规定\n.【强制】ArrayList 的 subList 结果不可强转成 ArrayList，否则会抛出 ClassCastException 异常：\njava.util.RandomAccessSubList cannot be cast to java.util.ArrayList。\n说明：subList() 返回的是 ArrayList 的内部类 SubList，并不是 ArrayList 本身，而是 ArrayList 的一个视图，对于\nSubList 的所有操作最终会反映到原列表上。\n例如:\n问题4.1：强转subList\nList&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();\nlist.add(&quot;1&quot;);\nlist.add(&quot;2&quot;);\nlist.add(&quot;3&quot;);\nlist.add(&quot;4&quot;);\nSystem.out.println(&quot;初始list:&quot; + list);\nList&lt;String&gt; strings &#x3D; (ArrayList)list.subList(0, 2);\n&#x2F;&#x2F;初始list:[1, 2, 3, 4]\n&#x2F;&#x2F;Exception in thread &quot;main&quot; java.lang.ClassCastException: class java.util.ArrayList$SubList cannot be &#x2F;&#x2F;cast to class java.util.ArrayList (java.util.ArrayList$SubList and java.util.ArrayList are in module &#x2F;&#x2F;java.base of loader &#39;bootstrap&#39;)\n&#x2F;&#x2F;\tat com.example.springbootdemo.test.ListTestDemo.main(ListTestDemo.java:18)\n\n问题4.2：修改SubList\nList&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();\nlist.add(&quot;1&quot;);\nlist.add(&quot;2&quot;);\nlist.add(&quot;3&quot;);\nlist.add(&quot;4&quot;);\nSystem.out.println(&quot;初始list:&quot; + list);\nList&lt;String&gt; strings &#x3D; list.subList(0, 2);\nSystem.out.println(&quot;截取过的list:&quot; + strings);\nstrings.add(&quot;5&quot;);\n\nSystem.out.println(&quot;初始list:&quot; + list);\nSystem.out.println(&quot;截取过的list:&quot; + strings);\n\n&#x2F;&#x2F;初始list:[1, 2, 3, 4]\n&#x2F;&#x2F;截取过的list:[1, 2]\n&#x2F;&#x2F;初始list:[1, 2, 5, 3, 4]\n&#x2F;&#x2F;截取过的list:[1, 2, 5]\n\n\n问题原因: SubList 是一个继承 AbstractList 的内部类，在 SubList 的构建函数中的将 List 中的部分属性直接赋予给自己。\nSubList 没有创建一个新的 List，而是直接引用了原来的 List(this.root &#x3D; root)，并根据offset和size来展示SubList的内容。\n所以 subList 方法不能直接转成 ArrayList，他只是ArrayList的内部类，没有其他的关系。\n因为是引用的关系，所以对subList产生的List做出结构型修改，操作会反应到原来的List上。\n如果修改原来的List则会抛出异常ConcurrentModificationException\n&#x2F;&#x2F;arrayList.class\n\npublic List&lt;E&gt; subList(int fromIndex, int toIndex) &#123;\n  subListRangeCheck(fromIndex, toIndex, size);\n  return new SubList&lt;&gt;(this, fromIndex, toIndex);\n&#125;\n\nprivate static class SubList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess &#123;\n  private final ArrayList&lt;E&gt; root;\n  private final SubList&lt;E&gt; parent;\n  private final int offset;\n  private int size;\n\n  &#x2F;**\n         * Constructs a sublist of an arbitrary ArrayList.\n         *&#x2F;\n  public SubList(ArrayList&lt;E&gt; root, int fromIndex, int toIndex) &#123;\n    this.root &#x3D; root;\n    this.parent &#x3D; null;\n    this.offset &#x3D; fromIndex;\n    this.size &#x3D; toIndex - fromIndex;\n    this.modCount &#x3D; root.modCount;\n  &#125;\n  ...\n&#125;\n\n解决方案:在操作SubList的时候，new一个新的ArrayList来接收创建subList结果的拷贝\nList strings &#x3D; new ArrayList(list.subList(0, 2));\n\n问题5:修改原列表会抛出异常。\n\n\n\n\n\n\n\n\n修改原列表会更改list的modCount属性的值\nList&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();\nlist.add(&quot;1&quot;);\nlist.add(&quot;2&quot;);\nlist.add(&quot;3&quot;);\nlist.add(&quot;4&quot;);\nSystem.out.println(&quot;初始list:&quot; + list);\nList&lt;String&gt; strings &#x3D; list.subList(0, 2);\nSystem.out.println(&quot;截取过的list:&quot; + strings);\nstrings.add(&quot;5&quot;);\nlist.add(&quot;6&quot;);\nSystem.out.println(&quot;初始list:&quot; + list);\nSystem.out.println(&quot;截取过的list:&quot; + strings);\n\n&#x2F;*\n初始list:[1, 2, 3, 4]\n截取过的list:[1, 2]\n初始list:[1, 2, 5, 3, 4, 6]\nException in thread &quot;main&quot; java.util.ConcurrentModificationException\n\tat java.base&#x2F;java.util.ArrayList$SubList.checkForComodification(ArrayList.java:1415)\n\tat java.base&#x2F;java.util.ArrayList$SubList.listIterator(ArrayList.java:1284)\n\tat java.base&#x2F;java.util.AbstractList.listIterator(AbstractList.java:311)\n\tat java.base&#x2F;java.util.ArrayList$SubList.iterator(ArrayList.java:1280)\n\tat java.base&#x2F;java.util.AbstractCollection.toString(AbstractCollection.java:449)\n\tat java.base&#x2F;java.lang.StringConcatHelper.stringOf(StringConcatHelper.java:453)\n\tat java.base&#x2F;java.lang.StringConcatHelper.simpleConcat(StringConcatHelper.java:408)\n\tat com.example.springbootdemo.test.ListTestDemo.main(ListTestDemo.java:23)\n*&#x2F;\n\n问题原因:原来的List插入了一个新元素，导致this.modCount不第一次保存的不一致则抛出异常\nprivate void checkForComodification() &#123;\n  if (root.modCount !&#x3D; modCount)\n    throw new ConcurrentModificationException();\n&#125;\n\n解决方案:在操作SubList的时候，new一个新的ArrayList来接收创建subList结果的拷贝\nList strings &#x3D; new ArrayList(list.subList(0, 2));\n\n问题6: ArrayList中的subList造成OOM\n\n\n\n\n\n\n\n\n在上面的例子中，我们知道了subList所产生的List，其实是对原来List对象的引用\n这个产生的List只是原来List对象的视图，也就是说虽然值切片获取了一小段数据，但是原来的List对象却得不到回收，这个原来的List对象可能是一个很大的对象\n为了方便我们测试，将vm调整一下 -Xms20m -Xmx40m\n\nList data &#x3D; new ArrayList();\nIntStream.range(0, 1000).forEach(i -&gt; &#123;\n  List&lt;Integer&gt; collect &#x3D; IntStream.range(0, 100000).boxed().collect(Collectors.toList());\n  data.add(collect.subList(0, 1));\n&#125;);\nSystem.out.println(data);\n\n&#x2F;&#x2F;Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space\n\n\n\n问题原因:出现OOM的原因，循环1000次创建了1000个具有10万个元素的List\n因为始终被collect.subList(0, 1)强引用，得不到回收\n解决方案：\n在subList方法返回SubList，重新使用new ArrayList，来构建一个独立的ArrayList\n\nList data &#x3D; new ArrayList();\nIntStream.range(0, 1000).forEach(i -&gt; &#123;\nList&lt;Integer&gt; collect &#x3D; IntStream.range(0, 100000).boxed().collect(Collectors.toList());\nList list &#x3D; new ArrayList&lt;&gt;(collect.subList(0, 1));\n&#x2F;&#x2F;  List list &#x3D; collect.stream().skip(0).limit(1).collect(Collectors.toList());\ndata.add(list);\n&#125;);\nSystem.out.println(data);\n\n\n利用Java8的Stream中的skip和limit来达到切片的目的\n\nList list &#x3D; collect.stream().skip(0).limit(1).collect(Collectors.toList());\n\n在这里我们可以看到，只要用一个新的容器来装结果，就可以切断与原始List的关系\n","slug":"java/list/ListAndArrayQuestion","date":"2022-09-23T02:41:39.000Z","categories_index":"JAVA,List","tags_index":"List","author_index":"HeouHou"},{"id":"078f7e9be7e83a4bdc132dd63c7d9a7c","title":"List和Array 中遇到的问题。","content":"List和Array 中遇到的问题。前言\n\n\n\n\n\n\n\n\n主要介绍Array 和List 互相转换时遇到的问题，以及怎么解决\nArrays.asList转换的坑问题1:基本类型数组转换List会出现转换出的结果跟想要的不一致\n\n\n\n\n\n\n\n\n我们进行数组转List的操作时，通常我们会使用Arrays.asList来进行转换。\n但是在转换基本类型的数组的时候，却出现转换的结果和我们想象的不一致。\n例如：\nvoid Test1()&#123;\n  int[] arr &#x3D; &#123;1, 2, 3&#125;;\n  List list &#x3D; Arrays.asList(arr);\n  System.out.println(list.size());\n  &#x2F;&#x2F;1\n&#125;\n\n我们的目的是想生成一个长度为3的List,可是现在只生成了长度为1 的List\n@SafeVarargs\n@SuppressWarnings(&quot;varargs&quot;)\npublic static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123;\n  return new ArrayList&lt;&gt;(a);\n&#125;\n\n问题原因:通过断点我们可以看到把 int数组 整体作为一个对象,返回了一个 List&lt;int[]&gt;\n这个源码的截图看出来的问题就是的这里出入的参数类型是泛型T，这就是问题的根源。这个T表示派生自Object类的任何类，比如String,Integer,Double等等。泛型只能是引用类型,基础类型int、double等不是引用类型，但是数组是引用类型，那么这个参数泛型T只能是数组的引用类型。所以我们传基础类数组的时候，就只会认为你只传一个值。\n解决方案方案一：Java8以上，利用Arrays.stream(arr).boxed()将装箱为Integer数组\nList collect &#x3D; Arrays.stream(arr).boxed().collect(Collectors.toList()); \nSystem.out.println(collect.size()); \nSystem.out.println(collect.get(0).getClass()); \n&#x2F;&#x2F; 3 \n&#x2F;&#x2F; class java.lang.Integer\n\n方案二：声明数组的时候，声明类型改为包装类型\nInteger[] integerArr &#x3D; &#123;1, 2, 3&#125;; \nList integerList &#x3D; Arrays.asList(integerArr); \nSystem.out.println(integerList.size());\nSystem.out.println(integerList.get(0).getClass()); \n&#x2F;&#x2F; 3 \n&#x2F;&#x2F; class java.lang.Integer\n\n问题2： Arrays.asList返回的List不支持增删操作\n\n\n\n\n\n\n\n\n使用Arrays.asList 返回的List 进行增加、刪除操作时会报错。\n例如：\n1.迭代器删除\nString[] arr &#x3D; &#123;&quot;1&quot;, &quot;2&quot;, &quot;4&quot;&#125;;\nList&lt;String&gt; strings &#x3D; Arrays.asList(arr);\n&#x2F;&#x2F; arr[2] &#x3D; &quot;4&quot;;\nSystem.out.println(strings);\nIterator&lt;String&gt; iterator &#x3D; strings.iterator();\nwhile (iterator.hasNext()) &#123;\n  if (&quot;4&quot;.equals(iterator.next())) &#123;\n    iterator.remove();\n  &#125;\n&#125;\n\n&#x2F;&#x2F;[1, 2, 4]\n&#x2F;&#x2F;Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException: remove\n\t&#x2F;&#x2F;at java.base&#x2F;java.util.Iterator.remove(Iterator.java:102)\n\t&#x2F;&#x2F;at com.example.springbootdemo.test.ListTestDemo.main(ListTestDemo.java:21)\n\n2.调用remove 和add 方法\n\nString[] arr &#x3D; &#123;&quot;1&quot;, &quot;2&quot;, &quot;4&quot;&#125;;\nList&lt;String&gt; strings &#x3D; Arrays.asList(arr);\nstrings.remove(&quot;4&quot;);\n&#x2F;&#x2F;Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException: remove\n\t&#x2F;&#x2F;at java.base&#x2F;java.util.Iterator.remove(Iterator.java:102)\n\t&#x2F;&#x2F;at java.base&#x2F;java.util.AbstractCollection.remove(AbstractCollection.java:283)\n\t&#x2F;&#x2F;at com.example.springbootdemo.test.ListTestDemo.main(ListTestDemo.java:25)\n\nstrings.add(&quot;3&quot;);\n&#x2F;&#x2F;Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException\n\t&#x2F;&#x2F;at java.base&#x2F;java.util.AbstractList.add(AbstractList.java:153)\n\t&#x2F;&#x2F;at java.base&#x2F;java.util.AbstractList.add(AbstractList.java:111)\n\t&#x2F;&#x2F;at com.example.springbootdemo.test.ListTestDemo.main(ListTestDemo.java:26)\n\n\n问题原因:根据源码可知:Arrays.asList(arr); 方法返回的List是 自己内部定义的内部类ArrayList,继承AbstractList 类。但是并没有实现add和remove方法。所以直接调用的是AbstractList 类中的方法，直接抛出异常\n&#x2F;&#x2F;Arrays.class\n\n@SafeVarargs\n@SuppressWarnings(&quot;varargs&quot;)\npublic static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123;\n  return new ArrayList&lt;&gt;(a);\n&#125;\n\n&#x2F;**\n     * @serial include\n     *&#x2F;\nprivate static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;\n  implements RandomAccess, java.io.Serializable\n&#123;\n  @java.io.Serial\n  private static final long serialVersionUID &#x3D; -2764017481108945198L;\n  @SuppressWarnings(&quot;serial&quot;) &#x2F;&#x2F; Conditionally serializable\n  private final E[] a;\n\n  ArrayList(E[] array) &#123;\n    a &#x3D; Objects.requireNonNull(array);\n  &#125;\n\n  @Override\n  public int size() &#123;\n    return a.length;\n  &#125;\n\n  @Override\n  public Object[] toArray() &#123;\n    return Arrays.copyOf(a, a.length, Object[].class);\n  &#125;\n\n  @Override\n  @SuppressWarnings(&quot;unchecked&quot;)\n  public &lt;T&gt; T[] toArray(T[] a) &#123;\n    ...\n  &#125;\n\n  @Override\n  public E get(int index) &#123;\n    return a[index];\n  &#125;\n\n  @Override\n  public E set(int index, E element) &#123;\n    E oldValue &#x3D; a[index];\n    a[index] &#x3D; element;\n    return oldValue;\n  &#125;\n\n  @Override\n  public int indexOf(Object o) &#123;\n    ...\n  &#125;\n\n  @Override\n  public boolean contains(Object o) &#123;\n    return indexOf(o) &gt;&#x3D; 0;\n  &#125;\n\n  @Override\n  public Spliterator&lt;E&gt; spliterator() &#123;\n    return Spliterators.spliterator(a, Spliterator.ORDERED);\n  &#125;\n\n  @Override\n  public void forEach(Consumer&lt;? super E&gt; action) &#123;\n    ...\n  &#125;\n\n  @Override\n  public void replaceAll(UnaryOperator&lt;E&gt; operator) &#123;\n    ...\n  &#125;\n\n  @Override\n  public void sort(Comparator&lt;? super E&gt; c) &#123;\n    Arrays.sort(a, c);\n  &#125;\n\n  @Override\n  public Iterator&lt;E&gt; iterator() &#123;\n    return new ArrayItr&lt;&gt;(a);\n  &#125;\n&#125;\n\n&#x2F;&#x2F; AbstractList.class\npublic abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; &#123;\n  public void add(int index, E element) &#123;\n \t\tthrow new UnsupportedOperationException();\n  &#125;\n  public E remove(int index) &#123;\n  \tthrow new UnsupportedOperationException();\n  &#125;\n&#125;\n\n\n同理。Iterator 类也是自己的内部类，也没有实现Iterator中的remove方法\n&#x2F;&#x2F;Arrays.class\n\nprivate static class ArrayItr&lt;E&gt; implements Iterator&lt;E&gt; &#123;\n  private int cursor;\n  private final E[] a;\n\n  ArrayItr(E[] a) &#123;\n    this.a &#x3D; a;\n  &#125;\n\n  @Override\n  public boolean hasNext() &#123;\n    return cursor &lt; a.length;\n  &#125;\n\n  @Override\n  public E next() &#123;\n    int i &#x3D; cursor;\n    if (i &gt;&#x3D; a.length) &#123;\n      throw new NoSuchElementException();\n    &#125;\n    cursor &#x3D; i + 1;\n    return a[i];\n  &#125;\n&#125;\n\n&#x2F;&#x2F;Iterator.class\n\npublic interface Iterator&lt;E&gt; &#123;\n  default void remove() &#123;\n \t throw new UnsupportedOperationException(&quot;remove&quot;);\n  &#125;\n&#125;\n\n解决方案重新new 一个ArrayList来接收。\nString[] arr &#x3D; &#123;&quot;1&quot;, &quot;2&quot;, &quot;4&quot;&#125;;\nList&lt;String&gt; strings &#x3D; new ArrayList&lt;&gt;(Arrays.asList(arr));\n\nSystem.out.println(&quot;初始值:&quot; + strings);\nIterator&lt;String&gt; iterator &#x3D; strings.iterator();\nwhile (iterator.hasNext()) &#123;\n  if (&quot;4&quot;.equals(iterator.next())) &#123;\n    iterator.remove();\n  &#125;\n&#125;\nSystem.out.println(&quot;删除元素4:&quot; + strings);\nstrings.remove(&quot;2&quot;);\nSystem.out.println(&quot;删除元素2&quot; + strings);\nstrings.add(&quot;3&quot;);\nSystem.out.println(&quot;增加元素3&quot; + strings);\n\n初始值:[1, 2, 4]\n删除元素4:[1, 2]\n删除元素2[1]\n增加元素3[1, 3]\n\n问题3: 对原始数组的修改会影响到我们获得的那个List\n\n\n\n\n\n\n\n\n完成字符串数组转换为List之后，我们将字符串数组的第三个对象的值修改为4，发现List也发生了变化。\n例如:\nString[] arr &#x3D; &#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;&#125;;\nList&lt;String&gt; strings &#x3D; Arrays.asList(arr);\nSystem.out.println(&quot;原始值:&quot; + strings);\narr[2] &#x3D; &quot;4&quot;;\nSystem.out.println(&quot;修改后的值:&quot; + strings);\n\n&#x2F;&#x2F;原始值:[1, 2, 3]\n&#x2F;&#x2F;修改后的值:[1, 2, 4]\n\n问题原因:根据源码可知。asList中创建了 ArrayList，但是他直接引用了原本的数组对象。所以只要原本的数组对象一发生变化，List也跟着变化\n&#x2F;&#x2F;Arrays.class\n\n@SafeVarargs\n@SuppressWarnings(&quot;varargs&quot;)\npublic static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123;\n  return new ArrayList&lt;&gt;(a);\n&#125;\n\n&#x2F;**\n     * @serial include\n     *&#x2F;\nprivate static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;\n  implements RandomAccess, java.io.Serializable\n&#123;\n  @java.io.Serial\n    private static final long serialVersionUID &#x3D; -2764017481108945198L;\n  @SuppressWarnings(&quot;serial&quot;) &#x2F;&#x2F; Conditionally serializable\n  private final E[] a;\n\n  ArrayList(E[] array) &#123;\n    a &#x3D; Objects.requireNonNull(array);\n  &#125;\n  ...\n&#125;\npublic static &lt;T&gt; T requireNonNull(T obj) &#123;\n  if (obj &#x3D;&#x3D; null)\n    throw new NullPointerException();\n  return obj;\n&#125;\n\n所以在使用时一定要注意修改数组时会导致List的修改。\n解决方案重新new 一个ArrayList来接收。\nString[] arr &#x3D; &#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;&#125;;\nList&lt;String&gt; strings &#x3D; new ArrayList&lt;&gt;(Arrays.asList(arr));\nSystem.out.println(&quot;原始值:&quot; + strings);\narr[2] &#x3D; &quot;4&quot;;\nSystem.out.println(&quot;修改后的值:&quot; + strings);\n&#x2F;&#x2F;原始值:[1, 2, 3]\n&#x2F;&#x2F;修改后的值:[1, 2, 3]\n\n\nArrayList中 subList 方法的坑问题4：①ArrayList中的 subList 强转 ArrayList 导致异常。②并且对于SubList 的所有操作最终会反映到原列表上。\n\n\n\n\n\n\n\n\n在阿里巴巴的《JAVA开发手册》中，有关于subList 的规定\n.【强制】ArrayList 的 subList 结果不可强转成 ArrayList，否则会抛出 ClassCastException 异常：\njava.util.RandomAccessSubList cannot be cast to java.util.ArrayList。\n说明：subList() 返回的是 ArrayList 的内部类 SubList，并不是 ArrayList 本身，而是 ArrayList 的一个视图，对于\nSubList 的所有操作最终会反映到原列表上。\n例如:\n问题4.1：强转subList\nList&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();\nlist.add(&quot;1&quot;);\nlist.add(&quot;2&quot;);\nlist.add(&quot;3&quot;);\nlist.add(&quot;4&quot;);\nSystem.out.println(&quot;初始list:&quot; + list);\nList&lt;String&gt; strings &#x3D; (ArrayList)list.subList(0, 2);\n&#x2F;&#x2F;初始list:[1, 2, 3, 4]\n&#x2F;&#x2F;Exception in thread &quot;main&quot; java.lang.ClassCastException: class java.util.ArrayList$SubList cannot be &#x2F;&#x2F;cast to class java.util.ArrayList (java.util.ArrayList$SubList and java.util.ArrayList are in module &#x2F;&#x2F;java.base of loader &#39;bootstrap&#39;)\n&#x2F;&#x2F;\tat com.example.springbootdemo.test.ListTestDemo.main(ListTestDemo.java:18)\n\n问题4.2：修改SubList\nList&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();\nlist.add(&quot;1&quot;);\nlist.add(&quot;2&quot;);\nlist.add(&quot;3&quot;);\nlist.add(&quot;4&quot;);\nSystem.out.println(&quot;初始list:&quot; + list);\nList&lt;String&gt; strings &#x3D; list.subList(0, 2);\nSystem.out.println(&quot;截取过的list:&quot; + strings);\nstrings.add(&quot;5&quot;);\n\nSystem.out.println(&quot;初始list:&quot; + list);\nSystem.out.println(&quot;截取过的list:&quot; + strings);\n\n&#x2F;&#x2F;初始list:[1, 2, 3, 4]\n&#x2F;&#x2F;截取过的list:[1, 2]\n&#x2F;&#x2F;初始list:[1, 2, 5, 3, 4]\n&#x2F;&#x2F;截取过的list:[1, 2, 5]\n\n\n问题原因: SubList 是一个继承 AbstractList 的内部类，在 SubList 的构建函数中的将 List 中的部分属性直接赋予给自己。\nSubList 没有创建一个新的 List，而是直接引用了原来的 List(this.root &#x3D; root)，并根据offset和size来展示SubList的内容。\n所以 subList 方法不能直接转成 ArrayList，他只是ArrayList的内部类，没有其他的关系。\n因为是引用的关系，所以对subList产生的List做出结构型修改，操作会反应到原来的List上。\n如果修改原来的List则会抛出异常ConcurrentModificationException\n&#x2F;&#x2F;arrayList.class\n\npublic List&lt;E&gt; subList(int fromIndex, int toIndex) &#123;\n  subListRangeCheck(fromIndex, toIndex, size);\n  return new SubList&lt;&gt;(this, fromIndex, toIndex);\n&#125;\n\nprivate static class SubList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess &#123;\n  private final ArrayList&lt;E&gt; root;\n  private final SubList&lt;E&gt; parent;\n  private final int offset;\n  private int size;\n\n  &#x2F;**\n         * Constructs a sublist of an arbitrary ArrayList.\n         *&#x2F;\n  public SubList(ArrayList&lt;E&gt; root, int fromIndex, int toIndex) &#123;\n    this.root &#x3D; root;\n    this.parent &#x3D; null;\n    this.offset &#x3D; fromIndex;\n    this.size &#x3D; toIndex - fromIndex;\n    this.modCount &#x3D; root.modCount;\n  &#125;\n  ...\n&#125;\n\n解决方案:在操作SubList的时候，new一个新的ArrayList来接收创建subList结果的拷贝\nList strings &#x3D; new ArrayList(list.subList(0, 2));\n\n问题5:修改原列表会抛出异常。\n\n\n\n\n\n\n\n\n修改原列表会更改list的modCount属性的值\nList&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();\nlist.add(&quot;1&quot;);\nlist.add(&quot;2&quot;);\nlist.add(&quot;3&quot;);\nlist.add(&quot;4&quot;);\nSystem.out.println(&quot;初始list:&quot; + list);\nList&lt;String&gt; strings &#x3D; list.subList(0, 2);\nSystem.out.println(&quot;截取过的list:&quot; + strings);\nstrings.add(&quot;5&quot;);\nlist.add(&quot;6&quot;);\nSystem.out.println(&quot;初始list:&quot; + list);\nSystem.out.println(&quot;截取过的list:&quot; + strings);\n\n&#x2F;*\n初始list:[1, 2, 3, 4]\n截取过的list:[1, 2]\n初始list:[1, 2, 5, 3, 4, 6]\nException in thread &quot;main&quot; java.util.ConcurrentModificationException\n\tat java.base&#x2F;java.util.ArrayList$SubList.checkForComodification(ArrayList.java:1415)\n\tat java.base&#x2F;java.util.ArrayList$SubList.listIterator(ArrayList.java:1284)\n\tat java.base&#x2F;java.util.AbstractList.listIterator(AbstractList.java:311)\n\tat java.base&#x2F;java.util.ArrayList$SubList.iterator(ArrayList.java:1280)\n\tat java.base&#x2F;java.util.AbstractCollection.toString(AbstractCollection.java:449)\n\tat java.base&#x2F;java.lang.StringConcatHelper.stringOf(StringConcatHelper.java:453)\n\tat java.base&#x2F;java.lang.StringConcatHelper.simpleConcat(StringConcatHelper.java:408)\n\tat com.example.springbootdemo.test.ListTestDemo.main(ListTestDemo.java:23)\n*&#x2F;\n\n问题原因:原来的List插入了一个新元素，导致this.modCount不第一次保存的不一致则抛出异常\nprivate void checkForComodification() &#123;\n  if (root.modCount !&#x3D; modCount)\n    throw new ConcurrentModificationException();\n&#125;\n\n解决方案:在操作SubList的时候，new一个新的ArrayList来接收创建subList结果的拷贝\nList strings &#x3D; new ArrayList(list.subList(0, 2));\n\n问题6: ArrayList中的subList造成OOM\n\n\n\n\n\n\n\n\n在上面的例子中，我们知道了subList所产生的List，其实是对原来List对象的引用\n这个产生的List只是原来List对象的视图，也就是说虽然值切片获取了一小段数据，但是原来的List对象却得不到回收，这个原来的List对象可能是一个很大的对象\n为了方便我们测试，将vm调整一下 -Xms20m -Xmx40m\n\nList data &#x3D; new ArrayList();\nIntStream.range(0, 1000).forEach(i -&gt; &#123;\n  List&lt;Integer&gt; collect &#x3D; IntStream.range(0, 100000).boxed().collect(Collectors.toList());\n  data.add(collect.subList(0, 1));\n&#125;);\nSystem.out.println(data);\n\n&#x2F;&#x2F;Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space\n\n\n\n问题原因:出现OOM的原因，循环1000次创建了1000个具有10万个元素的List\n因为始终被collect.subList(0, 1)强引用，得不到回收\n解决方案：\n在subList方法返回SubList，重新使用new ArrayList，来构建一个独立的ArrayList\n\nList data &#x3D; new ArrayList();\nIntStream.range(0, 1000).forEach(i -&gt; &#123;\nList&lt;Integer&gt; collect &#x3D; IntStream.range(0, 100000).boxed().collect(Collectors.toList());\nList list &#x3D; new ArrayList&lt;&gt;(collect.subList(0, 1));\n&#x2F;&#x2F;  List list &#x3D; collect.stream().skip(0).limit(1).collect(Collectors.toList());\ndata.add(list);\n&#125;);\nSystem.out.println(data);\n\n\n利用Java8的Stream中的skip和limit来达到切片的目的\n\nList list &#x3D; collect.stream().skip(0).limit(1).collect(Collectors.toList());\n\n在这里我们可以看到，只要用一个新的容器来装结果，就可以切断与原始List的关系\n","slug":"ListAndArrayQuestion","date":"2022-09-23T02:41:39.000Z","categories_index":"JAVA,List","tags_index":"List","author_index":"HeouHou"},{"id":"31ef586bea96124b8eeb710d561ee429","title":"SpringBoot  Value 注解注入static 字段","content":"普通参数使用@Value 示例:public class Utils &#123;\n    @Value(&quot;$&#123;test.host&#125;&quot;)\n    private  String host;\n\n    @Value(&quot;$&#123;test.port&#125;&quot;)\n    private  String port;\n\n    ......\n&#125;\n\n但是在注入static字段时,直接使用 @Value 为静态变量赋值是不行的，可以使用 set 方法：@Component\npublic class Utils &#123;\n    private static String host;\n\n    @Value(&quot;$&#123;test.host&#125;&quot;)\n    public void setHost(String host) &#123;\n        Utils.host &#x3D; host;\n    &#125;\n\n    private static String port;\n\n    @Value(&quot;$&#123;test.port&#125;&quot;)\n    public void setPort(String port) &#123;\n        Utils.port &#x3D; port;\n    &#125;\n\n    ......\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n注意，需要使用 @Component 注解。\n","slug":"springboot-value-zhu-jie-zhu-ru-static-zi-duan","date":"2019-05-14T05:45:27.000Z","categories_index":"java,Spring","tags_index":"注解","author_index":"HeouHou"},{"id":"3e82e95d63c1de4d51c37731b5b54831","title":"linux下常用Redis命令","content":"1. 连接redis redis-cli -h host -p port -a password\nredis-cli -h r-bp1e481.redis.rds.aliyuncs.com  -p 6379 -a password\n\n\n有时候会有中文乱码。要在 redis-cli 后面加上 –raw\nredis-cli --raw\n就可以避免中文乱码了\n2. 退出QUIT\n\n3.删除所有数据flushDB\n","slug":"linux/linux-redis","date":"2019-06-04T02:20:01.000Z","categories_index":"LINUX","tags_index":"Redis,LINUX","author_index":"HeouHou"},{"id":"04e053ae2c75962b1f5ddfabcc8b2f71","title":"linux下常用FTP命令","content":"1.连接Ftpftp 地址 端口\nftp 222.190.111.146 19001\n然后输入账号输入密码\n2. 退出bye\n","slug":"linux/linux-ftp","date":"2019-06-04T02:11:47.000Z","categories_index":"LINUX","tags_index":"LINUX,FTP","author_index":"HeouHou"},{"id":"0e355bb8eab52bcceb365d2e4cf83cbf","title":"java8新特性  Lambda","content":"Lambda 的使用\n\n\nLambda 表达式的示例:package com.example.demo.lambda;\n\nimport com.example.demo.domain.Employee;\nimport com.example.demo.service.Impl.FilterEmployeesByAge;\nimport com.example.demo.service.Impl.FilterEmployeesBySalary;\nimport com.example.demo.service.MyPredicate;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.TreeSet;\nimport org.junit.Test;\n\n&#x2F;**\n * @author houqingxin\n * @Description:\n * @date 2019-05-23 10:46\n *&#x2F;\npublic class TestController &#123;\n\n\n  &#x2F;&#x2F;原来的匿名内部类\n  @Test\n  public void test1() &#123;\n    Comparator&lt;Integer&gt; comparator &#x3D; new Comparator&lt;Integer&gt;() &#123;\n      @Override\n      public int compare(Integer o1, Integer o2) &#123;\n        return Integer.compare(o2, o1);\n      &#125;\n    &#125;;\n    TreeSet&lt;Integer&gt; integers &#x3D; new TreeSet&lt;&gt;(comparator);\n    integers.add(1);\n    integers.add(3);\n    integers.add(2);\n    System.out.println(integers);\n\n  &#125;\n\n  &#x2F;&#x2F;Lambda\n  @Test\n  public void test2() &#123;\n    Comparator&lt;Integer&gt; comparator &#x3D; (x, y) -&gt; Integer.compare(y, x);\n    TreeSet&lt;Integer&gt; integers &#x3D; new TreeSet&lt;&gt;(comparator);\n    integers.add(1);\n    integers.add(3);\n    integers.add(2);\n    System.out.println(integers);\n  &#125;\n\n  &#x2F;&#x2F;需求: 获取年龄大于35的员工信息\n  List&lt;Employee&gt; employees &#x3D; Arrays.asList(\n      new Employee(&quot;张三&quot;, 18, 1999),\n      new Employee(&quot;李四&quot;, 28, 2999),\n      new Employee(&quot;王五&quot;, 38, 3999),\n      new Employee(&quot;赵六&quot;, 48, 4999)\n  );\n\n  public List&lt;Employee&gt; filterEmployeesByAge(List&lt;Employee&gt; employees) &#123;\n    List&lt;Employee&gt; resultEmployees &#x3D; new ArrayList&lt;&gt;();\n    for (Employee employee : employees) &#123;\n      if (employee.getAge() &gt; 35) &#123;\n        resultEmployees.add(employee);\n      &#125;\n    &#125;\n    return resultEmployees;\n  &#125;\n\n  @Test\n  public void test3() &#123;\n    List&lt;Employee&gt; employee &#x3D; filterEmployeesByAge(employees);\n    System.out.println(employee);\n  &#125;\n\n  &#x2F;&#x2F;需求: 获取工资大于3000的员工信息\n  public List&lt;Employee&gt; filterEmployeesBySalary(List&lt;Employee&gt; employees) &#123;\n    List&lt;Employee&gt; resultEmployees &#x3D; new ArrayList&lt;&gt;();\n    for (Employee employee : employees) &#123;\n      if (employee.getSalary() &gt; 3000) &#123;\n        resultEmployees.add(employee);\n      &#125;\n    &#125;\n    return resultEmployees;\n  &#125;\n\n  @Test\n  public void test4() &#123;\n    List&lt;Employee&gt; employee &#x3D; filterEmployeesBySalary(employees);\n    System.out.println(employee);\n  &#125;\n\n  &#x2F;&#x2F;优化方式一 : 策略设计模式\n\n  public List&lt;Employee&gt; filterEmployees(List&lt;Employee&gt; employees,\n      MyPredicate&lt;Employee&gt; myPredicate) &#123;\n    List&lt;Employee&gt; resultEmployees &#x3D; new ArrayList&lt;&gt;();\n    for (Employee employee : employees) &#123;\n      if (myPredicate.test(employee)) &#123;\n        resultEmployees.add(employee);\n      &#125;\n    &#125;\n    return resultEmployees;\n  &#125;\n\n  @Test\n  public void test5() &#123;\n    List&lt;Employee&gt; employee &#x3D; filterEmployees(employees, new FilterEmployeesByAge());\n    System.out.println(employee);\n\n    System.out.println(&quot;------------------------------&quot;);\n\n    List&lt;Employee&gt; employee2 &#x3D; filterEmployees(employees, new FilterEmployeesBySalary());\n    System.out.println(employee2);\n  &#125;\n\n  &#x2F;&#x2F;优化方式二: 匿名内部类\n  @Test\n  public void test6() &#123;\n    List&lt;Employee&gt; employees &#x3D; filterEmployees(this.employees, new MyPredicate&lt;Employee&gt;() &#123;\n          @Override\n          public Boolean test(Employee employee) &#123;\n            return employee.getSalary() &lt; 2000;\n          &#125;\n        &#125;\n    );\n    System.out.println(employees);\n  &#125;\n\n  &#x2F;&#x2F;优化方式三:匿名内部类\n  @Test\n  public void test7() &#123;\n\n    List&lt;Employee&gt; employees &#x3D; filterEmployees(this.employees, (x) -&gt; x.getSalary() &lt; 2000);\n    System.out.println(employees);\n  &#125;\n\n  &#x2F;&#x2F;优化方式四:Stream API\n  @Test\n  public void test8() &#123;\n    employees.stream()\n        .filter((x) -&gt; x.getSalary() &lt; 2000)\n        .forEach(System.out::println);\n  &#125;\n\n&#125;\n\n&#x2F;&#x2F;实体对象\npackage com.example.demo.domain;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n&#x2F;**\n * @author houqingxin\n * @Description:\n * @date 2019-05-22 14:26\n *&#x2F;\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Employee &#123;\n\n  private String name;\n  private int age;\n  private int salary;\n\n&#125;\n\n\n&#x2F;&#x2F;接口\n\npackage com.example.demo.service;\n\n&#x2F;**\n * @author houqingxin\n * @Description:\n * @date 2019-05-23 11:12\n *&#x2F;\npublic interface MyPredicate&lt;T&gt; &#123;\n\n  Boolean test(T t);\n\n&#125;\n\n\npackage com.example.demo.service.impl;\n\nimport com.example.demo.domain.Employee;\nimport com.example.demo.service.MyPredicate;\n\n&#x2F;**\n * @author houqingxin\n * @Description:\n * @date 2019-05-23 11:21\n *&#x2F;\npublic class FilterEmployeesByAge implements MyPredicate&lt;Employee&gt; &#123;\n\n  @Override\n  public Boolean test(Employee employee) &#123;\n    return employee.getAge() &gt; 35;\n  &#125;\n&#125;\n\n&#x2F;&#x2F;实现方法\npackage com.example.demo.service.impl;\n\nimport com.example.demo.domain.Employee;\nimport com.example.demo.service.MyPredicate;\n\n&#x2F;**\n * @author houqingxin\n * @Description:\n * @date 2019-05-23 11:21\n *&#x2F;\npublic class FilterEmployeesByAge implements MyPredicate&lt;Employee&gt; &#123;\n\n  @Override\n  public Boolean test(Employee employee) &#123;\n    return employee.getAge() &gt; 35;\n  &#125;\n&#125;\n\npackage com.example.demo.service.impl;\n\n    import com.example.demo.domain.Employee;\n    import com.example.demo.service.MyPredicate;\n\n&#x2F;**\n * @author houqingxin\n * @Description:\n * @date 2019-05-23 11:37\n *&#x2F;\npublic class FilterEmployeesBySalary implements MyPredicate&lt;Employee&gt; &#123;\n\n  @Override\n  public Boolean test(Employee employee) &#123;\n    return employee.getSalary() &lt; 3500;\n  &#125;\n\n&#125;\n\n\n\n\nLambda 表达式的基本语法java8中引用了一个新的操作符&quot;-&gt;&quot; 该操作符称为箭头操作符 或Lambda操作符\n箭头操作符将Lambda表达式拆分成两部分:\n左侧: Lambda 表达式的参数列表\n右侧: Lambda 表达式中所需执行的功能,即Lambda 体\n\n1. 语法格式一: 无参,无返回值()-&gt;System.out.println(&quot;Hello Lambda&quot;);\n\n@Test\npublic void test1() &#123;\n  Runnable runnable &#x3D; () -&gt; System.out.println(&quot;Hello Lambda!&quot;);\n  runnable.run();\n&#125;\n\n\n\n2. 语法格式二: 有一个参数 ,无返回值 (若只有一个参数,小括号可省略不写)(x)-&gt;System.out.println(x);\nx-&gt;System.out.println(x);\n\n@Test\npublic void test2() &#123;\n    Consumer&lt;String&gt; consumer &#x3D; x -&gt; System.out.println(x);\n    consumer.accept(&quot;测试&quot;);\n&#125;\n\n3. 语法格式三: 有两个以上参数,有返回值,并且Lambda体中有多条语句Comparator&lt;Integer&gt; comparator = (x, y) -&gt; &#123;\n  System.out.println(&quot;--------&quot;);\n  return Integer.compare(x, y);\n&#125;;\n\n@Test\npublic void test3() &#123;\n  Comparator&lt;Integer&gt; comparator &#x3D; (x, y) -&gt; &#123;\n    System.out.println(&quot;--------&quot;);\n    return Integer.compare(x, y);\n  &#125;;\n  int result &#x3D; comparator.compare(17, 11);\n  System.out.println(result);\n&#125;\n\n\n\n4.语法格式四: 若Lambda 体中只有一条语句,return 和大括号都可以不写Comparator&lt;Integer&gt; comparator = (x, y) -&gt;Integer.compare(x, y);\n\n5. 语法格式五:  Lamba 表达式的参数列表的数据类型可以省略不写,因为JVM编译器通过上下文推断出,数据类型,即”类型推断”.Java8 内置四大核心函数式接口&#x2F;**\n  * Java8内置的四大核心函数式接口\n  * &lt;p&gt;\n  * Consumer&lt;T&gt;: 消费型接口\n  * void accept(T t);\n  *\n  * Supplier&lt;T&gt;:供给型接口\n  * T get();\n  *\n  * Function&lt;T, R&gt;: 函数型接口\n  * R apply(T t);\n  *\n  * Predicate&lt;T&gt;: 断言型接口:\n  * boolean test(T t);\n  *\n  *Java8中还提供了其他函数式接口\n*&#x2F;\n\n方法引用: 若Lambda 体中的内容有方法已经实现了,我们可以使用”方法引用”    (可以理解为方法引用是Lambda 表达式的另外一种表现形式)    主要有三种语法格式:\n\n\n\n\n\n\n\n\n\n注意:Lambda 体中调用方法的参数列表和返回值类型,要与函数式接口中抽象方法的函数列表和返回值类型保持一致\n①对象::实例方法名\n\n@Test\npublic void test4() &#123;\n  PrintStream out &#x3D; System.out;\n  Consumer&lt;String&gt; consumer &#x3D; x -&gt; out.println(x);\n  Consumer&lt;String&gt; consumer1 &#x3D; out::println;\n  consumer.accept(&quot;测试1&quot;);\n  consumer1.accept(&quot;测试2&quot;);\n&#125;\n\n@Test\npublic void test5() &#123;\n  Employee employee &#x3D; new Employee();\n  employee.setName(&quot;hah&quot;);\n  Supplier&lt;String&gt; stringSupplier &#x3D; () -&gt; employee.getName();\n  String s &#x3D; stringSupplier.get();\n  System.out.println(s);\n  Supplier&lt;String&gt; getName &#x3D; employee::getName;\n  String s1 &#x3D; getName.get();\n  System.out.println(s1);\n\n&#125;\n\n②类::静态方法名\n\n@Test\npublic void test6() &#123;\n  Comparator&lt;Integer&gt; comparator &#x3D; (x, y) -&gt; Integer.compare(x, y);\n  Comparator&lt;Integer&gt; comparator1 &#x3D; Integer::compare;\n&#125;\n\n③类::实例方法名\n若 Lambda 参数列表中的第一参数是实例方法的调用者,而第二个参数是实例方法的参数时,可以使用\nClassName::method\n\n@Test\n public void test7() &#123;\n   BiPredicate&lt;String, String&gt; biPredicate &#x3D; (x, y) -&gt; x.equals(y);\n   BiPredicate&lt;String, String&gt; biPredicate1 &#x3D; String::equals;\n &#125;\n构造器引用格式:\nClassName::new\n\n\n\n\n\n\n\n\n\n\n注意:需要调用的构造器的参数列表要与函数式接口中的抽象方法参数列表保持一致\n@Test\npublic void test8() &#123;\n  Supplier&lt;Employee&gt; stringSupplier &#x3D; () -&gt; new Employee();\n  Supplier&lt;Employee&gt; stringSupplier2 &#x3D; Employee::new;\n&#125;\n\n@Test\npublic void test9() &#123;\n  Function&lt;Integer, Employee&gt; function &#x3D; (x) -&gt; new Employee(x);\n  Function&lt;Integer, Employee&gt; function1 &#x3D; Employee::new;\n&#125;\n\n数组引用Type[]::new\n\n@Test\n public void test10() &#123;\n   Function&lt;Integer, String[]&gt; function &#x3D; (x) -&gt; new String[x];\n   Function&lt;Integer, String[]&gt; function1 &#x3D; String[]::new;\n &#125;","slug":"java/java8-lambda","date":"2019-05-23T02:41:39.000Z","categories_index":"java","tags_index":"Lambda","author_index":"HeouHou"},{"id":"e5e12e562a6b766ad292ef7e2566a53a","title":"SpringBoot项目搭建 :使用Swagger2构建强大的RESTful API文档","content":"1. 添加Swagger2依赖 在pom.xml中加入Swagger2的依赖\n&lt;!--swagger--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;springfox-swagger2&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.9.2&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;springfox-swagger-ui&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.9.2&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n2. 创建Swagger2配置类@Configuration\n@EnableSwagger2\npublic class SwaggerConfig &#123;\n\n  @Value(value &#x3D; &quot;$&#123;swagger.enabled&#125;&quot;)\n  Boolean swaggerEnabled;\n\n  @Bean\n  public Docket createRestApi() &#123;\n   &#x2F;* ParameterBuilder tokenParam &#x3D; new ParameterBuilder();\n    List&lt;Parameter&gt; params &#x3D; new ArrayList&lt;&gt;();\n    tokenParam.name(&quot;Authorization&quot;).description(&quot;令牌Token&quot;).modelRef(new ModelRef(&quot;string&quot;))\n        .parameterType(&quot;header&quot;).required(false).build();\n    params.add(tokenParam.build());*&#x2F;\n\n    return new Docket(DocumentationType.SWAGGER_2)\n        .groupName(&quot;v1.0&quot;)\n        .apiInfo(apiInfo())\n        .enable(swaggerEnabled)\n        .select()\n        .apis(RequestHandlerSelectors.basePackage(&quot;com.example.demo&quot;))\n        .paths(PathSelectors.any())\n        .build()\n        .pathMapping(&quot;&quot;);\n  &#125;\n\n  private ApiInfo apiInfo() &#123;\n    return new ApiInfoBuilder()\n        .title(&quot;SpringBootDemo-API&quot;)\n        .description(&quot;SpringBoot项目搭建&quot;)\n        .contact(new Contact(&quot;hou&quot;, &quot;www.buhaoji.top&quot;, &quot;843882065@qq.com&quot;))\n        .version(&quot;1.0.0&quot;)\n        .build();\n  &#125;\n\n&#125;\n如上代码所示，通过@Configuration注解，让Spring来加载该类配置。再通过@EnableSwagger2注解来启用Swagger2。再通过createRestApi函数创建Docket的Bean之后，apiInfo()用来创建该Api的基本信息（这些基本信息会展现在文档页面中）。select()函数返回一个ApiSelectorBuilder实例用来控制哪些接口暴露给Swagger来展现，本例采用指定扫描的包路径来定义，Swagger会扫描该包下所有Controller定义的API，并产生文档内容（除了被@ApiIgnore指定的请求）。\n3. 添加文档内容在完成了上述配置后，其实已经可以生产文档内容，但是这样的文档主要针对请求本身，而描述主要来源于函数等命名产生，对用户并不友好，我们通常需要自己增加一些说明来丰富文档内容。如下所示，我们通过@ApiOperation注解来给API增加说明、通过@ApiImplicitParams、@ApiImplicitParam注解来给参数增加说明。\n&#x2F;&#x2F;TODO\n4.swagger 相关注解5.swagger 分组","slug":"springboot-swagger2","date":"2019-05-16T05:55:51.000Z","categories_index":"java,Spring,SpringBoot","tags_index":"","author_index":"HeouHou"},{"id":"c7433ee36363ab590f7e0ac5e549f564","title":"SpringMVC之请求参数的获取方式","content":"原文链接\nI. GET请求参数获取get请求参数，一般都是直接挂在请求的url上，所以获取这些参数还是比较简单的\n1. 通过 HttpServletRequest获取参数这个可以说是最基本最常见的的方式了，  javax.servlet.ServletRequest#getParameter来获取对应的参数 \n@RestController\n@RequestMapping(path &#x3D; &quot;webs&#x2F;demo&quot;)\npublic class DemoController &#123;\n\n    @RequestMapping(path &#x3D; &quot;req1&quot;)\n    public String req1(HttpServletRequest request) &#123;\n        String user &#x3D; request.getParameter(&quot;user&quot;);\n        String password &#x3D; request.getParameter(&quot;password&quot;);\n        return &quot;req1 user: &quot; + user + &quot; pwd: &quot; + password;\n    &#125;\n&#125;\n根据上面暴露的接口，我们测试的case就很简单了\nhttp:&#x2F;&#x2F;127.0.0.1:8080&#x2F;webs&#x2F;demo&#x2F;req1?user&#x3D;小灰灰Blog&amp;password&#x3D;123456\n## 输出  req1 user: 小灰灰Blog pwd: 123456\n\nhttp:&#x2F;&#x2F;127.0.0.1:8080&#x2F;webs&#x2F;demo&#x2F;req1?user&#x3D;小灰灰Blog\n## 输出  req1 user: 小灰灰Blog pwd: null\n 说明:\n\n这是一个最基本的获取参数的方式，get，post请求都适用的，通常在filter,intercepter中也是可以通过HttpServletRequest对象来获取请求参数\n除了获取常见的请求参数之外，HttpServletRequest可以获取请求头的完整信息\n在一次请求的生命周期内，可以通过下面的方式获取Request对象(当然也可以获取response对象)\n\nHttpServletRequest httpServletRequest &#x3D; ((ServletRequestAttributes) \n    RequestContextHolder.getRequestAttributes()).getRequest();\n2. 直接方法参数获取@RequestMapping(path &#x3D; &quot;req2&quot;)\npublic String req2(String user, String password) &#123;\n    return &quot;req2 user: &quot; + user + &quot; pwd: &quot; + password;\n&#125;\n请求验证\nhttp:&#x2F;&#x2F;127.0.0.1:8080&#x2F;webs&#x2F;demo&#x2F;req2?user&#x3D;%E5%B0%8F%E7%81%B0%E7%81%B0Blog&amp;password&#x3D;123456\n## 输出： req2 user: 小灰灰Blog pwd: 123456\n\nhttp:&#x2F;&#x2F;127.0.0.1:8080&#x2F;webs&#x2F;demo&#x2F;req2?password&#x3D;123456\n## 输出： req2 user: null pwd: 123456\n\nhttp:&#x2F;&#x2F;127.0.0.1:8080&#x2F;webs&#x2F;demo&#x2F;req2?password&#x3D;123456&amp;User&#x3D;blog\n## 输出： req2 user: null pwd: 123456\n 注意:\n\n上面这种使用方式，相当于直接将url参数映射到了Controller方法的参数上了\n方法参数名必须和url参数名完全一致（区分大小写）\n顺序无关\n若参数没传，则默认为null\n\n\n\n\n\n\n\n\n\n\n一个疑问 上面的demo中Controller的方法参数都是String还好，如果将password改成int，会出现什么情况\n@RequestMapping(path &#x3D; &quot;req2&quot;)\npublic String req2(String user, int password) &#123;\n    return &quot;req2 user: &quot; + user + &quot; pwd: &quot; + password;\n&#125;\n实际测试\n# case1 \nhttp:&#x2F;&#x2F;127.0.0.1:8080&#x2F;webs&#x2F;demo&#x2F;req2?password&#x3D;123456&amp;user&#x3D;blog\n## 输出： req2 user: blog pwd: 123456\n\n\n# case 2\nhttp:&#x2F;&#x2F;127.0.0.1:8080&#x2F;webs&#x2F;demo&#x2F;req2?password2&#x3D;123456&amp;user&#x3D;blog\n## 输出: 报错, Optional int parameter &#39;password&#39; is present but cannot be translated into a null value due to being declared as a primitive type. Consider declaring it as object wrapper for the corresponding primitive type\n\n\n# case 3\nhttp:&#x2F;&#x2F;127.0.0.1:8080&#x2F;webs&#x2F;demo&#x2F;req2?password&#x3D;abc&amp;user&#x3D;blog\n## 输出：报错, &quot;Failed to convert value of type &#39;java.lang.String&#39; to required type &#39;int&#39;; nested exception is java.lang.NumberFormatException: For input string: &quot;abc&quot;&quot;\n\n说明:\n\n如果请求参数与方法参数类型不一致，会抛出转换异常\n如果方法参数为非封装基本类型，则url参数必须存在，否则报错\n\n3. RequestParam注解方式获取请求参数通过@RequestParam注解获取参数的方式和上面的一种比较类似\n@RequestMapping(path &#x3D; &quot;req3&quot;, method &#x3D; RequestMethod.GET)\npublic String req3(@RequestParam(&quot;user&quot;) String username,\n                   @RequestParam(&quot;password&quot;) String pwd) &#123;\n    return &quot;req3 user: &quot; + username + &quot; pwd: &quot; + pwd;\n&#125;\n\n# case1 \nhttp:&#x2F;&#x2F;127.0.0.1:8080&#x2F;webs&#x2F;demo&#x2F;req3?password&#x3D;123456&amp;user&#x3D;blog\n## 输出: req3 user: blog pwd: 123456\n\n\n# case2\nhttp:&#x2F;&#x2F;127.0.0.1:8080&#x2F;webs&#x2F;demo&#x2F;req3?password&#x3D;123456\n## 输出：报错， Required String parameter &#39;user&#39; is not presen\n说明:\n\n不指定注解的name或value属性时，等同于第二种使用姿势\n注解的name属性或value属性，用实际的参数名来指定\ncontroller的参数名与url参数名没有强关联（区别第二种方式）\n参数类型需要保证一致（通第二种方式）\n如果url参数可选，请设置require属性为false，如下\n\n@RequestParam(name &#x3D; &quot;user&quot;,  required &#x3D; false) String username\n\n4. Bean方式获取参数对于请求参数比较复杂的情况下，我比较喜欢这种使用姿势，管理起来方便简单\n@Data\npublic static class UserDO &#123;\n    String user;\n    String password;\n&#125;\n\n@RequestMapping(path &#x3D; &quot;req4&quot;, method &#x3D; RequestMethod.GET)\npublic String req4(UserDO userDO) &#123;\n    return &quot;req4 userDO: &quot; + userDO;\n&#125;\n测试case\n# case1\nhttp:&#x2F;&#x2F;127.0.0.1:8080&#x2F;webs&#x2F;demo&#x2F;req4?password&#x3D;123456&amp;user&#x3D;%E5%B0%8F%E7%81%B0%E7%81%B0Blog\n## 输出: req4 userDO: DemoController.UserDO(user&#x3D;小灰灰Blog, password&#x3D;123456)\n# case2\nhttp:&#x2F;&#x2F;127.0.0.1:8080&#x2F;webs&#x2F;demo&#x2F;req4?password&#x3D;123456\n## 输出: req4 userDO: DemoController.UserDO(user&#x3D;null, password&#x3D;123456)\n 说明:\n\n定义一个bean，内部属性和请求参数对应\n允许参数不存在的情况，会使用null代替（所以，尽量不要使用非封装基本类型，否则参数不传时，会抛异常）\nbean的属性，可以根据实际情况指定类型\n\n5. ModelAttribute注解方式@ModelAttribute注解的方法，会优于Controller之前执行，一般更常见于向视图传输数据使用，此处不详细展开，正常来讲，专门的获取参数不太会用这这种方式来玩\n6. Path参数Path参数，专指的是请求路径的参数，如\nhttp:&#x2F;&#x2F;127.0.0.1:8080&#x2F;webs&#x2F;demo&#x2F;req4?password&#x3D;123456\n上面这个url中，password是我们传统意义上的请求参数，其中path参数则是指其中 req4, demo这种path路径中的一环；对此，最常见的一个case就是常见的博客中,如开源中国的一个博客链接\n\nhttps:&#x2F;&#x2F;my.oschina.net&#x2F;u&#x2F;566591&#x2F;blog&#x2F;1601400\n566591 : 这个参数主要用来区分用户\n1601400 : 这个参数则主要是表示对应的博文\n一般path参数的获取方式如下\n\n@RequestMapping(path &#x3D; &quot;req6&#x2F;&#123;user&#125;&#x2F;info&quot;)\npublic String req6(@PathVariable(name &#x3D; &quot;user&quot;) String user) &#123;\n    return &quot;req6 user: &quot; + user;\n&#125;\n测试case\n# case1 \nhttp:&#x2F;&#x2F;127.0.0.1:8080&#x2F;webs&#x2F;demo&#x2F;req6&#x2F;blog&#x2F;info?user&#x3D;haha\n## 输出：req6 user: blog\n\n# case2\nhttp:&#x2F;&#x2F;127.0.0.1:8080&#x2F;webs&#x2F;demo&#x2F;req6&#x2F;blog?user&#x3D;haha\n## 输出: 404\n\n# case3\nhttp:&#x2F;&#x2F;127.0.0.1:8080&#x2F;webs&#x2F;demo&#x2F;req6&#x2F;info?user&#x3D;haha\n## 输出: 404\n\n 注意:\n\npath参数的使用，需要确保参数存在且类型匹配\npath参数和url参数不会相互影响\n\nII. POST请求参数获取POST请求参数，更多的是看提交表单参数是否可以获取到，以及如何获取，主要的手段依然是上面几种方式，下面验证下是否ok\n1. HttpServletRequest方式获取参数测试case，可以借助curl来实现post请求\n# case1 \ncurl -d &quot;user&#x3D;小灰灰Blog&amp;password&#x3D;123456&quot; &quot;http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;webs&#x2F;demo&#x2F;req1&quot;\n## 输出： req1 user: 小灰灰Blog pwd: 123456\n\n# case2\ncurl -d &quot;user&#x3D;小灰灰Blog&quot; &quot;http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;webs&#x2F;demo&#x2F;req1?password&#x3D;123456&quot;\n## 输出：req1 user: 小灰灰Blog pwd: 12345\n\n# case3\ncurl -d &quot;user&#x3D;小灰灰Blog&quot; &quot;http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;webs&#x2F;demo&#x2F;req1?user&#x3D;greyBlog&quot;\n## 输出：req1 user: greyBlog pwd: null\ncurl也可以换成js请求测试方式\nvar formData &#x3D; new FormData();\nformData.append(&quot;user&quot;, &quot;小灰灰Blog&quot;);\n\n$.ajax(&#123;\n  url: &#39;http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;webs&#x2F;demo&#x2F;req1?password&#x3D;123456&#39;,\n  type: &#39;post&#39;,\n  cache: false,\n  data: formData,\n  processData: false,\n  contentType: false\n&#125;);\n 说明:\n\n对于HttpServletReuqest方式获取参数时，get和post没什么区别\n若url参数和表单参数同名了，测试结果显示使用的是url参数（待确认，当然最好不要这么干）\n\n2. 方法参数获取几个测试demo如下\n# case 1\ncurl -d &quot;user&#x3D;小灰灰Blog&amp;password&#x3D;123456&quot; &quot;http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;webs&#x2F;demo&#x2F;req2&quot;\n## 输出： req2 user: 小灰灰Blog pwd: 123456\n\n# case 2\ncurl -d &quot;password&#x3D;123456&quot; &quot;http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;webs&#x2F;demo&#x2F;req2&quot;\n## 输出：req2 user: null pwd: 123456\n\n# case 3\ncurl -d &quot;password&#x3D;123456&quot; &quot;http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;webs&#x2F;demo&#x2F;req2?user&#x3D;blog&quot;\n## 输出： req2 user: blog pwd: 123456\n基本上使用姿势和get没什么区别\n\n3. RequestParam注解方式# case 1\ncurl -d &quot;password&#x3D;123456&amp;user&#x3D;blog&quot; &quot;http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;webs&#x2F;demo&#x2F;req3&quot;\n## 输出： req3 user: blog pwd: 123456\n\n# case 2\ncurl -d &quot;password&#x3D;123456&quot; &quot;http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;webs&#x2F;demo&#x2F;req3?user&#x3D;blog&quot;\n## 输出： req3 user: blog pwd: 123456\n\n# case 3\ncurl -d &quot;password&#x3D;123456&amp;user&#x3D;blog&quot; &quot;http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;webs&#x2F;demo&#x2F;req3?password&#x3D;900&quot;\n## 输出：req3 user: blog pwd: 900,123456\n 注意:\n\n和前面的两种方式不同的是，当post表单的参数和url参数同名时，会合并成一个字符串\n\n4. Bean方式## case1 \ncurl -d &quot;password&#x3D;123456&amp;user&#x3D;blog&quot; &quot;http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;webs&#x2F;demo&#x2F;req4?password&#x3D;900&quot;\n## 输出 req4 userDO: DemoController.UserDO(user&#x3D;blog, password&#x3D;900,123456)\n\n## case2\ncurl -d &quot;password&#x3D;123456&amp;user&#x3D;blog&quot; &quot;http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;webs&#x2F;demo&#x2F;req4&quot;\n## 输出 req4 userDO: DemoController.UserDO(user&#x3D;blog, password&#x3D;123456)\n\n## case3\ncurl -d &quot;password&#x3D;123456&quot; &quot;http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;webs&#x2F;demo&#x2F;req4&quot;\n## 输出 req4 userDO: DemoController.UserDO(user&#x3D;null, password&#x3D;123456)\n这种方式不区分get,post，所以完全复杂的交互接口，完全可以考虑用bean的方式来定义请求参数\n5. PathVariable这个没法玩…\nIII. 多媒体上传参数获取上传文件的支持，对于传统的spring-mvc来说，可能需要一些添加一些相关配置，不在本文的范畴内，下面默认已经配置好\n1. 实例支持@RequestMapping(path &#x3D; &#123;&quot;wx&#x2F;upload&quot;, &quot;wx&#x2F;wx&#x2F;upload&quot;&#125;, method &#x3D; &#123;RequestMethod.GET, RequestMethod.POST, RequestMethod.OPTIONS&#125;)\n@ResponseBody\npublic String upload(HttpServletRequest request) &#123;\n    MultipartFile file &#x3D; null;\n    if (request instanceof MultipartHttpServletRequest) &#123;\n        file &#x3D; ((MultipartHttpServletRequest) request).getFile(&quot;image&quot;);\n    &#125;\n\n    if (file &#x3D;&#x3D; null) &#123;\n        throw new IllegalArgumentException(&quot;图片不能为空!&quot;);\n    &#125;\n    \n    return &quot;success&quot;;\n&#125;\n简单来说，主要是利用HttpServletRequest来获取上传的文件\n 注意:\n\n如果接口必须要求上传文件，可以直接把参数声明为 MultipartHttpServletRequest， 此时调用方如果不传参数，会被异常拦截（可以通过@ControllerAdvice来拦截全局异常）\n如果可以不上传文件，则可以用上面的这种猥琐姿势，内部进行判断\n((MultipartHttpServletRequest) request).getFile(xxx)来获取指定名的上传文件\n\nIV. 小结1. 五种获取参数的姿势\n\n\n方式\n注意事项\n\n\n\nHttpServletRequest获取参数\n最常见通用\n\n\n方法参数与请求参数同名\n注意参数名统一，注意类型一致，尽量不用非包装基本类型\n\n\n@RequestParam注解\n同上，可注解内指定http参数名\n\n\nBean方式\n定义一个bean，会将同名的http参数赋值进去，推荐\n\n\n@PathVariable 注解\n请求url参数\n\n\n2. 传文件使用姿势\n使用MultipartHttpServletRequest来获取上传的文件，当然也可以获取基本的请求参数\n\n","slug":"springmvc-request","date":"2019-05-15T09:33:12.000Z","categories_index":"java,Spring","tags_index":"注解","author_index":"HeouHou"},{"id":"de81b5153735c56c5894060bd22ba7e2","title":"Spring 注解 @RequestParam 的使用","content":"@RequestParam 参数加与不加的区别@RequestMapping(&quot;&#x2F;list&quot;)\npublic String test(int userId) &#123;\n    return &quot;list&quot;;\n&#125;\n \n@RequestMapping(&quot;&#x2F;list&quot;)\npublic String test(@RequestParam int userId) &#123;\n    return &quot;list&quot;;\n&#125;\n\n第一种写法参数为非必传，第二种写法参数为必传。参数名为userId。\n第二种写法可以通过@RequestParam(required &#x3D; false)设置为非必传。因为required值默认是true，所以默认必传。\n第二种写法可以通过@RequestParam(“userId”)或者@RequestParam(value &#x3D; “userId”)指定参数名。\n第二种写法可以通过@RequestParam(defaultValue &#x3D; “0”)指定参数默认值\n\n\n\n\n\n\n\n\n\n当@RequestParam(required &#x3D; false) 或不加 @RequestParam时, 参数类型为int,该参数不传,会报错,因为如果不传,会把null 复制到int,会报错.   推荐使用包装类Integer \n","slug":"requestparam","date":"2019-05-14T06:04:05.000Z","categories_index":"java,Spring","tags_index":"注解","author_index":"HeouHou"},{"id":"f735a8432adb840ff75c82713f30b58a","title":"ActiveMQ 入门","content":"介绍MQ是消息中间件，是一种在分布式系统中应用程序借以传递消息的媒介，常用的有ActiveMQ，RabbitMQ，kafka。ActiveMQ是Apache下的开源项目，完全支持JMS1.1和J2EE1.4规范的JMS Provider实现。\n  \n特点：\n支持多种语言编写客户端 \n对spring的支持，很容易和spring整合 \n支持多种传输协议：TCP,SSL,NIO,UDP等 \n支持AJAX\n\n消息形式：\n点对点（queue） \n一对多（topic）\n\n安装\n\n\n\n\n\n\n\n\n参考链接\n\n下载apache-activemq-5.13.1-bin.tar.gz   下载地址：http://download.csdn.net/download/u014223912/9464747\n\n下载后解压 \n\n进入到&#x2F;apache-activemq-5.13.1&#x2F;bin&#x2F;macosx目录 \n\n启动ActiveMQ\n   .&#x2F;activemq start  \n在浏览器中 http://127.0.0.1:8161/admin/   默认用户名密码都为admin\n\n\n参考资料 https://blog.csdn.net/jiuqiyuliang/article/category/5617711\n","slug":"activeMQ-introduction","date":"2019-05-08T05:34:39.000Z","categories_index":"ActiveMQ","tags_index":"ActiveMQ","author_index":"HeouHou"},{"id":"245d2ad85dbb4cc07618cd240650f737","title":"Mac 安装 Mysql","content":"https://www.jianshu.com/p/4cb5ef29a099\n","slug":"macInstallMysql","date":"2019-04-29T02:35:08.000Z","categories_index":"mysql","tags_index":"brew,mysql","author_index":"HeouHou"},{"id":"f31c9c0d928594cba2cdbfcbf999a7bf","title":"git SSH 和 HTTP 的区别","content":"最近项目迁移到git上去,在提交代码时遇到了要每次输入账号密码的情况,查看资料时了解到了 http 和ssh 的问题,特此记录.百度了一下,大部分的回答如下:\nHTTP使用 http url 克隆对初学者来说会比较方便，复制 http url 然后到命令行里面直接用 git clone 命令克隆到本地就好了，在执行 clone 命令之后需要输入你的 GitLab 的帐号和密码。使用 git Bash 每次都需要输入帐号和密码，不过在使用 PhpStorm 时，PhpStorm 会记住你的用户名和密码，只需第一次使用时输入就好。\nSSH使用 SSH url 克隆却需要在克隆之前先配置和添加好 SSH key ，因此，如果你想要使用 SSH url 克隆的话，你必须是这个项目的拥有者。否则你是无法添加 SSH key 的，另外 ssh 默认是每次 fetch 和 push 代码都不需要输入账号和密码。\n","slug":"git-ssh-he-http-de-qu-bie","date":"2019-04-24T01:03:42.000Z","categories_index":"git","tags_index":"git","author_index":"HeouHou"},{"id":"7f76b5408d9d357744c33683204a51e2","title":"sourceTree 每次提交代码都要输入账号密码","content":"\n\n方法一: 使用ssh 方式做免密处理\n\n\n如果必须使用http 的方式\n方法二:在.git目录中有个config目录，在路径前配置下用户名和密码即可，如下所示：[core]\n    repositoryformatversion &#x3D; 0\n    filemode &#x3D; false\n    bare &#x3D; false\n    logallrefupdates &#x3D; true\n    symlinks &#x3D; false\n    ignorecase &#x3D; true\n[remote &quot;origin&quot;]\n    url &#x3D; http:&#x2F;&#x2F;账号:&#39;密码&#39;@192.168.10.7:8090&#x2F;test&#x2F;Django.git\n    fetch &#x3D; +refs&#x2F;heads&#x2F;*:refs&#x2F;remotes&#x2F;origin&#x2F;*\n[branch &quot;master&quot;]\n    remote &#x3D; origin\n    merge &#x3D; refs&#x2F;heads&#x2F;master\n\n\n\n方法三:设置对所有项目有效git config –global credential.helper osxkeychain  #第一次需要输入密码，以后都不需要了\n","slug":"sourcetree-mei-ci-ti-jiao-dai-ma-du-yao-shu-ru-zhang-hao-mi-ma","date":"2019-04-24T00:49:02.000Z","categories_index":"git","tags_index":"git,sourceTree","author_index":"HeouHou"}]